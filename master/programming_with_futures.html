
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Programming With Futures &mdash; junction v0.1.0 documentation</title>
    <link rel="stylesheet" href="static/nature.css" type="text/css" />
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="static/jquery.js"></script>
    <script type="text/javascript" src="static/underscore.js"></script>
    <script type="text/javascript" src="static/doctools.js"></script>
    <link rel="top" title="junction v0.1.0 documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">junction v0.1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="programming-with-futures">
<h1>Programming With Futures<a class="headerlink" href="#programming-with-futures" title="Permalink to this headline">¶</a></h1>
<p>Junction&#8217;s asynchronous RPC api involves a number of objects that meet
the definition of a <a class="reference external" href="http://en.wikipedia.org/wiki/Futures_and_promises">&#8220;future&#8221;</a>. The fit the bill because when initially
created, their results are not yet known but will be transparently
filled in when they arrive, or they can be explicitly waited for.</p>
<p>These are <a class="reference internal" href="junction/rpc.html#junction.core.rpc.RPC" title="junction.core.rpc.RPC"><tt class="xref py py-class docutils literal"><span class="pre">RPCs</span></tt></a> and
<a class="reference internal" href="junction/rpc.html#junction.core.rpc.Dependent" title="junction.core.rpc.Dependent"><tt class="xref py py-class docutils literal"><span class="pre">Dependents</span></tt></a>.
RPCs always correspond to a <a class="reference internal" href="junction/node.html#junction.node.Node.send_rpc" title="junction.node.Node.send_rpc"><tt class="xref py py-meth docutils literal"><span class="pre">single</span> <span class="pre">RPC</span> <span class="pre">call</span></tt></a>. Dependents can be built to wait on any
combination of RPCs and other Dependents, and they can either represent
a not-yet-started RPC or the results of any callback function.Dependents
wrap a callback that isn&#8217;t fired until all its parent futures are
complete, then calls the callback passing it the results of its parents,
and using the callback result as its own result (though if the callback
returns an RPC, that is then waited on as well and its results are used
as those of the Dependent).</p>
<p>Both objects share a common API, so in some circumstances can be used
interchangeably.</p>
<p>Using RPC instances with the <strong>send_rpc()</strong> and <strong>wait_any()</strong> methods
of <a class="reference internal" href="junction/node.html#junction.node.Node" title="junction.node.Node"><tt class="xref py py-class docutils literal"><span class="pre">Node</span></tt></a> and <a class="reference internal" href="junction/client.html#junction.client.Client" title="junction.client.Client"><tt class="xref py py-class docutils literal"><span class="pre">Client</span></tt></a> objects is a great way to parallelize RPCs
within a single coroutine, and Dependents are a natural extension of
that for when one needs to make RPC calls whose arguments are taken from
the results of prior RPCs.</p>
<p>But programming with futures can be much more effective when the future
objects themselves are used <em>instead of</em>, or <em>in place of</em> the results
they generate. Consider a webserver endpoint that will generate HTML for
an HTTP response out of data it collects with RPCs. This process doesn&#8217;t
usually actually need any of the data it collected until the very last
step, building the HTML (often rendering a template), so there should be
<em>NO</em> reason to wait on <em>anything</em> until then.</p>
<p>Before then, any place we would have passed RPC-collected data into a
function or had it in a variable, we can instead use a future for that
data in its place.  Anything that we would have done with that data, we
can instead do in a Dependent of the future. With this approach we can
maximize the parallelism between webserver and data providers and have
that parallelism track the true dependency graph between RPCs, rather
than end up with choke points scattered throughout the process.</p>
<p>Consider the simple example below of pseudocode validating an entered
username and password:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">username</span><span class="p">,</span> <span class="n">passwd</span><span class="p">):</span>
    <span class="n">userid</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">rpc</span><span class="p">(</span><span class="n">USERDATA_SERVICE</span><span class="p">,</span> <span class="s">&quot;by_username&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">username</span><span class="p">,),</span> <span class="p">{})[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">is_valid</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">rpc</span><span class="p">(</span><span class="n">PASSWORD_SERVICE</span><span class="p">,</span> <span class="s">&quot;validate&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">userid</span><span class="p">,</span> <span class="n">passwd</span><span class="p">),</span> <span class="p">{})[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">is_valid</span>
</pre></div>
</div>
<img alt="images/single_validate.png" src="images/single_validate.png" />
<p>To go async and program with futures, we must use a Dependent for the
second RPC as its arguments include the results from the first RPC.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">username</span><span class="p">,</span> <span class="n">passwd</span><span class="p">):</span>
    <span class="n">userid</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">send_rpc</span><span class="p">(</span><span class="n">USERDATA_SERVICE</span><span class="p">,</span> <span class="s">&quot;by_username&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">username</span><span class="p">,),</span> <span class="p">{})</span>

    <span class="nd">@userid.after</span>
    <span class="k">def</span> <span class="nf">is_valid</span><span class="p">(</span><span class="n">userid</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">send_rpc</span><span class="p">(</span><span class="n">PASSWORD_SERVICE</span><span class="p">,</span> <span class="s">&quot;validate&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">userid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">passwd</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">is_valid</span><span class="o">.</span><span class="n">wait</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>This doesn&#8217;t help us yet, though. There are only two RPCs here and the
second <em>must</em> wait for the first, and the method still blocks until both
RPCs have completed. Where the approach really helps us is when we need
to validate a batch of username, password pairs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">validations</span> <span class="o">=</span> <span class="p">[(</span><span class="n">un</span><span class="p">,</span> <span class="n">pw</span><span class="p">,</span> <span class="n">validate</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">un</span><span class="p">,</span> <span class="n">pw</span><span class="p">))</span> <span class="k">for</span> <span class="n">un</span><span class="p">,</span> <span class="n">pw</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">]</span>
</pre></div>
</div>
<img alt="images/seq_validates.png" src="images/seq_validates.png" />
<p>With just a tiny modification to the futures-based validate method, and
a little supporting code in the batching, we can get each of the
sequential RPC pairs happening together in parallel:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">username</span><span class="p">,</span> <span class="n">passwd</span><span class="p">):</span>
    <span class="n">userid</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">send_rpc</span><span class="p">(</span><span class="n">USERDATA_SERVICE</span><span class="p">,</span> <span class="s">&quot;by_username&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">username</span><span class="p">,),</span> <span class="p">{})</span>

    <span class="nd">@userid.after</span>
    <span class="k">def</span> <span class="nf">is_valid</span><span class="p">(</span><span class="n">userid</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">send_rpc</span><span class="p">(</span><span class="n">PASSWORD_SERVICE</span><span class="p">,</span> <span class="s">&quot;validate&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">userid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">passwd</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">is_valid</span>

<span class="n">with_futures</span> <span class="o">=</span> <span class="p">[(</span><span class="n">un</span><span class="p">,</span> <span class="n">pw</span><span class="p">,</span> <span class="n">validate</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">un</span><span class="p">,</span> <span class="n">pw</span><span class="p">))</span> <span class="k">for</span> <span class="n">un</span><span class="p">,</span> <span class="n">pw</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">]</span>
<span class="n">validations</span> <span class="o">=</span> <span class="p">[(</span><span class="n">un</span><span class="p">,</span> <span class="n">pw</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">wait</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">un</span><span class="p">,</span> <span class="n">pw</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">with_futures</span><span class="p">]</span>
</pre></div>
</div>
<img alt="images/par_validates.png" src="images/par_validates.png" />
<p>The only change to the validate function was that it now returns the
future pointing at the boolean result, rather than the result itself.
Doing it this way allows us to queue up all the RPCs before we have to
wait on any of them, allowing the whole process to be run in parallel
for each username/password pair.</p>
<div class="section" id="the-common-api-of-rpcs-and-dependents">
<h2>The Common API of RPCs and Dependents<a class="headerlink" href="#the-common-api-of-rpcs-and-dependents" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt><strong>complete</strong> attribute</dt>
<dd>True if the future is finished, and therefore &#8220;results&#8221; is available</dd>
<dt><strong>results</strong> attribute</dt>
<dd>Raises AttributeError if the future isn&#8217;t yet complete, but
otherwise produces the results of whatever future action the object
represents.</dd>
<dt><strong>wait()</strong> method</dt>
<dd>Blocks the current coroutine until the future is complete, and then
returns its results. Also accepts a timeout, however.</dd>
<dt><strong>abort()</strong> method</dt>
<dd>Prevents the future from completing, waking any coroutines that are
blocked waiting. Takes a single argument and sets that as the result
of this future. Also aborts any Dependents made to depend on this
future, passing the provided result down.</dd>
<dt><strong>after()</strong> method</dt>
<dd>Creates and returns a new <a class="reference internal" href="junction/rpc.html#junction.core.rpc.Dependent" title="junction.core.rpc.Dependent"><tt class="xref py py-class docutils literal"><span class="pre">Dependent</span></tt></a> that depends on this future. Also
optionally accepts a list of other future objects on which it should
depend.</dd>
<dt><strong>Node.wait_any()</strong> and <strong>Client.wait_any()</strong></dt>
<dd>Both <a class="reference internal" href="junction/node.html#junction.node.Node" title="junction.node.Node"><tt class="xref py py-class docutils literal"><span class="pre">Node</span></tt></a> and <a class="reference internal" href="junction/client.html#junction.client.Client" title="junction.client.Client"><tt class="xref py py-class docutils literal"><span class="pre">Client</span></tt></a> have a method &#8220;wait_all&#8221;, which accepts a
list of futures (these can be any mixtures of
<a class="reference internal" href="junction/rpc.html#junction.core.rpc.RPC" title="junction.core.rpc.RPC"><tt class="xref py py-class docutils literal"><span class="pre">RPCs</span></tt></a> and <a class="reference internal" href="junction/rpc.html#junction.core.rpc.Dependent" title="junction.core.rpc.Dependent"><tt class="xref py py-class docutils literal"><span class="pre">Dependents</span></tt></a>), and returns the first complete
future from the list.</dd>
</dl>
</div>
<div class="section" id="rpcs">
<h2>RPCs<a class="headerlink" href="#rpcs" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="junction/rpc.html#junction.core.rpc.RPC" title="junction.core.rpc.RPC"><tt class="xref py py-class docutils literal"><span class="pre">RPCs</span></tt></a> are created by calls to
<a class="reference internal" href="junction/node.html#junction.node.Node.send_rpc" title="junction.node.Node.send_rpc"><tt class="xref py py-meth docutils literal"><span class="pre">Node.send_rpc</span></tt></a> and
<a class="reference internal" href="junction/client.html#junction.client.Client.send_rpc" title="junction.client.Client.send_rpc"><tt class="xref py py-meth docutils literal"><span class="pre">Client.send_rpc</span></tt></a>. These objects
are a representation of the single in-flight RPC call.</p>
<p>The <a class="reference internal" href="junction/rpc.html#junction.core.rpc.RPC.results" title="junction.core.rpc.RPC.results"><tt class="xref py py-attr docutils literal"><span class="pre">results</span></tt></a> attribute will
always be a list, and it will be filled with the returned results from
each peer that was targeted by the RPC. In the event of an <a class="reference internal" href="junction/rpc.html#junction.core.rpc.RPC.abort" title="junction.core.rpc.RPC.abort"><tt class="xref py py-meth docutils literal"><span class="pre">abort</span></tt></a>, the results list will have length 1 &#8211;
the result passed into the abort method.</p>
<p>RPC objects also have two additional attributes that Dependents don&#8217;t:
<a class="reference internal" href="junction/rpc.html#junction.core.rpc.RPC.target_count" title="junction.core.rpc.RPC.target_count"><tt class="xref py py-attr docutils literal"><span class="pre">target_count</span></tt></a> and
<a class="reference internal" href="junction/rpc.html#junction.core.rpc.RPC.partial_results" title="junction.core.rpc.RPC.partial_results"><tt class="xref py py-attr docutils literal"><span class="pre">partial_results</span></tt></a>. These
aren&#8217;t possible for Dependents because they don&#8217;t necessarily correspond
to a single RPC, so target_count doesn&#8217;t make sense, and if its result
is simply the return value of its callback there will be no partial
results.</p>
</div>
<div class="section" id="dependents">
<h2>Dependents<a class="headerlink" href="#dependents" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="junction/rpc.html#junction.core.rpc.Dependent" title="junction.core.rpc.Dependent"><tt class="xref py py-class docutils literal"><span class="pre">Dependents</span></tt></a> are created by calls
to <a class="reference internal" href="junction/rpc.html#junction.core.rpc.RPC.after" title="junction.core.rpc.RPC.after"><tt class="xref py py-meth docutils literal"><span class="pre">RPC.after</span></tt></a> and
<a class="reference internal" href="junction/rpc.html#junction.core.rpc.Dependent.after" title="junction.core.rpc.Dependent.after"><tt class="xref py py-meth docutils literal"><span class="pre">Dependent.after</span></tt></a>. They wrap a
callback function (passed to <cite>after()</cite>), and call it when the future(s)
they depend on have finished.</p>
<p>Although they are created by the <cite>after()</cite> method of a single future, a
Dependent can have more than one parent (it will wait for all of its
parents to complete before firing its callback). To create a
multi-parent Dependent pass any additional future objects in a list as
the <cite>other_parents</cite> argument.</p>
<p>The Dependent&#8217;s callback should take as many arguments as it has
parents. The values passed in will be the results of the parents in
order (the future on which <cite>.after</cite> was called comes before the
<cite>other_parents</cite>). The return value of the callback matters as well. If
the Dependent callback returns an RPC (by calling <cite>send_rpc</cite> in the
callback), then the Dependent won&#8217;t be considered complete until that
RPC has completed, and the Dependent&#8217;s results will be taken straight
from the RPC. Effectively, the RPC takes the Dependent&#8217;s place in the
dependency graph. In any other case (the callback doesn&#8217;t return an RPC
instance), the return value is simply used as the Dependent&#8217;s result.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Programming With Futures</a><ul>
<li><a class="reference internal" href="#the-common-api-of-rpcs-and-dependents">The Common API of RPCs and Dependents</a></li>
<li><a class="reference internal" href="#rpcs">RPCs</a></li>
<li><a class="reference internal" href="#dependents">Dependents</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="sources/programming_with_futures.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">junction v0.1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010, Travis J Parker.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>